import * as THREE from "three";
export class BufferManager {
    /** The current size of the buffers. */
    get size() {
        const firstAttribute = this.attributes[0];
        return firstAttribute.count * 3;
    }
    get attributes() {
        return Object.values(this.geometry.attributes);
    }
    constructor(geometry) {
        this.geometry = geometry;
        /** Buffer increment when geometry size is exceeded, multiple of 3. */
        this.bufferIncrease = 300;
        /**
         * The maximum capacity of the buffers. If exceeded by the {@link size},
         * the buffers will be rescaled.
         */
        this.capacity = 0;
    }
    addAttribute(attribute) {
        this.geometry.setAttribute(attribute.name, attribute);
    }
    resetAttributes() {
        for (const attribute of this.attributes) {
            this.createAttribute(attribute.name);
        }
        this.capacity = 0;
    }
    createAttribute(name) {
        if (this.geometry.hasAttribute(name)) {
            this.geometry.deleteAttribute(name);
        }
        const attribute = new THREE.BufferAttribute(new Float32Array(0), 3);
        attribute.name = name;
        this.geometry.setAttribute(name, attribute);
    }
    updateCount(size) {
        for (const attribute of this.attributes) {
            attribute.count = size;
            attribute.needsUpdate = true;
        }
    }
    resizeIfNeeded(increase) {
        const newSize = this.size + increase * 3;
        const difference = newSize - this.capacity;
        if (difference >= 0) {
            const increase = Math.max(difference, this.bufferIncrease);
            const oldCapacity = this.capacity;
            this.capacity += increase;
            for (const attribute of this.attributes) {
                this.resizeBuffers(attribute, oldCapacity);
            }
        }
    }
    resizeBuffers(attribute, oldCapacity) {
        this.geometry.deleteAttribute(attribute.name);
        const array = new Float32Array(this.capacity);
        const newAttribute = new THREE.BufferAttribute(array, 3);
        newAttribute.name = attribute.name;
        newAttribute.count = attribute.count;
        this.geometry.setAttribute(attribute.name, newAttribute);
        for (let i = 0; i < oldCapacity; i++) {
            const x = attribute.getX(i);
            const y = attribute.getY(i);
            const z = attribute.getZ(i);
            newAttribute.setXYZ(i, x, y, z);
        }
    }
}
//# sourceMappingURL=buffer-manager.js.map