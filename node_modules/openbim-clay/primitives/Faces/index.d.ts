import * as THREE from "three";
import { Vertices } from "../Vertices";
import { Primitive } from "../Primitive";
import { Selector } from "../../utils";
interface Face {
    id: number;
    vertices: Set<number>;
    points: Set<number>;
    holes: {
        [id: string]: {
            id: number;
            points: Set<number>;
        };
    };
}
interface FacePoint {
    id: number;
    coordinates: [number, number, number];
    vertices: Set<number>;
    faces: Set<number>;
}
export declare class Faces extends Primitive {
    /** {@link Primitive.mesh } */
    mesh: THREE.Mesh;
    /**
     * The list of points that define the faces. Each point corresponds to a set of {@link Vertices}. This way,
     * we can provide an API of faces that share vertices, but under the hood the vertices are duplicated per face
     * (and thus being able to contain the normals as a vertex attribute).
     */
    points: {
        [id: number]: FacePoint;
    };
    /**
     * The list of faces. Each face is defined by a list of outer points.
     */
    list: {
        [id: number]: Face;
    };
    /**
     * The geometric representation of the vertices that define this instance of faces.
     */
    vertices: Vertices;
    /**
     * The list of selected {@link points}.
     */
    selectedPoints: Selector;
    private _vertexFaceMap;
    private _faceIdGenerator;
    private _pointIdGenerator;
    private _holeIdGenerator;
    /**
     * The color of all the points.
     */
    set baseColor(color: THREE.Color);
    /**
     * The color of all the selected points.
     */
    set selectColor(color: THREE.Color);
    private get _index();
    constructor();
    /**
     * Quickly removes all the faces and releases all the memory used.
     */
    clear(): void;
    /**
     * Adds a face.
     * @param ids - the IDs of the {@link points} that define that face. It's assumed that they are coplanar.
     * @param holesPointsIDs - the IDs of the {@link points} that define the holes.
     */
    add(ids: number[], holesPointsIDs?: number[][]): number;
    /**
     * Removes faces.
     * @param ids List of faces to remove. If no face is specified,
     * removes all the selected faces.
     */
    remove(ids?: Iterable<number>): void;
    /**
     * Adds the points that can be used by one or many faces
     */
    addPoints(points: [number, number, number][]): number[];
    removePoints(ids?: Iterable<number>): void;
    /**
     * Select or unselects the given faces.
     * @param active Whether to select or unselect.
     * @param ids List of faces IDs to select or unselect. If not
     * defined, all faces will be selected or deselected.
     */
    select(active: boolean, ids?: Iterable<number>): void;
    /**
     * Selects or unselects the given points.
     * @param active When true we will select, when false we will unselect
     * @param ids List of point IDs to add to the selected set. If not
     * defined, all points will be selected or deselected.
     */
    selectPoints(active: boolean, ids?: number[]): void;
    /**
     * Sets a point of the face to a specific position.
     * @param id The point whose position to set.
     * @param coordinates The new coordinates of the point.
     */
    setPoint(id: number, coordinates: [number, number, number]): void;
    /**
     * Applies a transformation to the selected vertices.
     * @param matrix Transformation matrix to apply.
     */
    transform(matrix: THREE.Matrix4): void;
    /**
     * Given a face index, returns the face ID.
     * @param faceIndex The index of the face whose ID to get.
     */
    getFromIndex(faceIndex: number): number | undefined;
    /**
     * Gets the center point of a face.
     * @param id The face whose center to get.
     */
    getCenter(id: number): number[] | null;
    /**
     * Gets the normalVector of a face.
     * @param id The face whose normal vector to get.
     */
    getNormal(id: number): number[] | null;
    private saveCoordinates;
    private updateBuffers;
    private updateColor;
    private triangulate;
    private getProjectionDimension;
    private getCoordinate;
}
export {};
