import { InstancedMesh, Color, } from "three";
import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter";
import { BufferAttribute } from "three/src/core/BufferAttribute";
export class FragmentMesh extends InstancedMesh {
    constructor(geometry, material, count, fragment) {
        super(geometry, material, count);
        this.elementCount = 0;
        this.exportOptions = {
            trs: false,
            onlyVisible: false,
            truncateDrawRange: true,
            binary: true,
            maxTextureSize: 0,
        };
        this.exporter = new GLTFExporter();
        this.material = FragmentMesh.newMaterialArray(material);
        this.geometry = this.newFragmentGeometry(geometry);
        this.fragment = fragment;
    }
    exportData() {
        const position = this.geometry.attributes.position.array;
        const normal = this.geometry.attributes.normal.array;
        const blockID = Array.from(this.geometry.attributes.blockID.array);
        const index = Array.from(this.geometry.index.array);
        const groups = [];
        for (const group of this.geometry.groups) {
            const index = group.materialIndex || 0;
            const { start, count } = group;
            groups.push(start, count, index);
        }
        const materials = [];
        if (Array.isArray(this.material)) {
            for (const material of this.material) {
                const opacity = material.opacity;
                const transparent = material.transparent ? 1 : 0;
                const color = new Color(material.color).toArray();
                materials.push(opacity, transparent, ...color);
            }
        }
        const matrices = Array.from(this.instanceMatrix.array);
        let colors;
        if (this.instanceColor !== null) {
            colors = Array.from(this.instanceColor.array);
        }
        else {
            colors = [];
        }
        return {
            position,
            normal,
            index,
            blockID,
            groups,
            materials,
            matrices,
            colors,
        };
    }
    export() {
        const mesh = this;
        return new Promise((resolve) => {
            this.exporter.parse(mesh, (geometry) => resolve(geometry), (error) => console.log(error), this.exportOptions);
        });
    }
    newFragmentGeometry(geometry) {
        if (!geometry.index) {
            throw new Error("The geometry must be indexed!");
        }
        if (!geometry.attributes.blockID) {
            const vertexSize = geometry.attributes.position.count;
            const array = new Uint16Array(vertexSize);
            array.fill(this.elementCount++);
            geometry.attributes.blockID = new BufferAttribute(array, 1);
        }
        const size = geometry.index.count;
        FragmentMesh.initializeGroups(geometry, size);
        return geometry;
    }
    static initializeGroups(geometry, size) {
        if (!geometry.groups.length) {
            geometry.groups.push({
                start: 0,
                count: size,
                materialIndex: 0,
            });
        }
    }
    static newMaterialArray(material) {
        if (!Array.isArray(material))
            material = [material];
        return material;
    }
}
//# sourceMappingURL=fragment-mesh.js.map